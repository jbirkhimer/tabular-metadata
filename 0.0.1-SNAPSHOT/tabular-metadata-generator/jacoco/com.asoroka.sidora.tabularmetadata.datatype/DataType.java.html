<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DataType.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Tabular Metadata Generator</a> &gt; <a href="index.source.html" class="el_package">com.asoroka.sidora.tabularmetadata.datatype</a> &gt; <span class="el_source">DataType.java</span></div><h1>DataType.java</h1><pre class="source lang-java linenums">/**
 * TEMPORARY LICENSE HEADER STANDIN
 * REPLACE WITH APPROPRIATE SIDORA LICENSE
 */

package com.asoroka.sidora.tabularmetadata.datatype;

import static com.google.common.base.Suppliers.memoize;
import static com.google.common.collect.Lists.transform;
import static com.google.common.collect.Sets.filter;
import static java.lang.Float.parseFloat;
import static java.lang.Integer.parseInt;
import static java.util.Arrays.asList;
import static java.util.Collections.max;
import static java.util.EnumSet.allOf;
import static java.util.regex.Pattern.CASE_INSENSITIVE;
import static java.util.regex.Pattern.compile;
import static javax.xml.XMLConstants.W3C_XML_SCHEMA_NS_URI;
import static org.joda.time.format.ISODateTimeFormat.dateTimeParser;

import java.net.URI;
import java.util.Collection;
import java.util.Comparator;
import java.util.EnumSet;
import java.util.List;
import java.util.Set;
import java.util.regex.Pattern;

import org.joda.time.DateTime;

import com.google.common.base.Function;
import com.google.common.base.Predicate;
import com.google.common.base.Supplier;

/**
 * This enumeration constructs
 * &lt;ul&gt;
 * &lt;li&gt;our &quot;native&quot; type system, as well as&lt;/li&gt;
 * &lt;li&gt;maps from lexical spaces in our system to selected portions of selected value spaces in the Java type system,
 * and&lt;/li&gt;
 * &lt;li&gt;maps from our types to types in the XSD type system.&lt;/li&gt;
 * &lt;/ul&gt;
 * It also offers convenience methods for working with our type system.
 * 
 * @author ajs6f
 */
<span class="fc" id="L47">public enum DataType {</span>

<span class="fc" id="L49">    String(W3C_XML_SCHEMA_NS_URI + &quot;string&quot;, null) {</span>

        /*
         * This override indicates that String is the top type.
         */
        @Override
        public Set&lt;DataType&gt; supertypes() {
<span class="fc" id="L56">            return EnumSet.of((DataType) this);</span>
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public String parse(final java.lang.String s) {
<span class="fc" id="L62">            return s;</span>
        }

    },
<span class="fc" id="L66">    Decimal(W3C_XML_SCHEMA_NS_URI + &quot;decimal&quot;, String) {</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public Float parse(final java.lang.String s) throws ParsingException {
            try {
<span class="fc" id="L72">                return parseFloat(s);</span>
<span class="fc" id="L73">            } catch (final NumberFormatException e) {</span>
<span class="fc" id="L74">                throw new ParsingException(&quot;Could not parse as Decimal!&quot;, e);</span>
            }
        }
    },
<span class="fc" id="L78">    Integer(W3C_XML_SCHEMA_NS_URI + &quot;integer&quot;, Decimal) {</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public Integer parse(final java.lang.String s) throws ParsingException {
            try {
<span class="fc" id="L84">                return parseInt(s);</span>
<span class="fc" id="L85">            } catch (final NumberFormatException e) {</span>
<span class="fc" id="L86">                throw new ParsingException(&quot;Could not parse as Integer!&quot;, e);</span>
            }
        }
    },
<span class="fc" id="L90">    NonNegativeInteger(W3C_XML_SCHEMA_NS_URI + &quot;nonNegativeInteger&quot;, Integer) {</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public Integer parse(final java.lang.String s) throws ParsingException {

<span class="fc" id="L96">            final Integer value = Integer.parse(s);</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">            if (value &gt; -1) {</span>
<span class="fc" id="L98">                return value;</span>
            }
<span class="fc" id="L100">            throw new ParsingException(&quot;Value was negative!&quot;);</span>
        }
    },
<span class="fc" id="L103">    PositiveInteger(W3C_XML_SCHEMA_NS_URI + &quot;positiveInteger&quot;, NonNegativeInteger) {</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public Integer parse(final java.lang.String s) throws ParsingException {
<span class="fc" id="L108">            final Integer value = NonNegativeInteger.parse(s);</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">            if (value &gt; 0) {</span>
<span class="fc" id="L110">                return value;</span>
            }
<span class="fc" id="L112">            throw new ParsingException(&quot;Value was negative!&quot;);</span>
        }
    },
<span class="fc" id="L115">    Geographic(null, String) {</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public GeographicValue parse(final String s) throws ParsingException {
            try {
<span class="fc" id="L121">                final List&lt;Float&gt; parts =</span>
                        transform(asList(s.split(&quot;,&quot;)), string2float);
<span class="fc" id="L123">                return new GeographicValue(parts);</span>
<span class="fc" id="L124">            } catch (final IllegalArgumentException e) {</span>
<span class="fc" id="L125">                throw new ParsingException(&quot;Could not parse as Geographic!&quot;, e);</span>
            }
        }
    },
<span class="fc" id="L129">    Boolean(W3C_XML_SCHEMA_NS_URI + &quot;boolean&quot;, String) {</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public Boolean parse(final java.lang.String s) throws ParsingException {
<span class="fc bfc" id="L134" title="All 2 branches covered.">            if (BOOLEAN_TRUE.matcher(s).matches()) {</span>
<span class="fc" id="L135">                return true;</span>
            }
<span class="fc bfc" id="L137" title="All 2 branches covered.">            if (BOOLEAN_FALSE.matcher(s).matches()) {</span>
<span class="fc" id="L138">                return false;</span>
            }
<span class="fc" id="L140">            throw new ParsingException(&quot;Could not parse as Boolean!&quot;);</span>
        }
    },
<span class="fc" id="L143">    DateTime(W3C_XML_SCHEMA_NS_URI + &quot;dateTime&quot;, String) {</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public DateTime parse(final java.lang.String s) throws ParsingException {
            try {
<span class="fc" id="L149">                return dateTimeParser().parseDateTime(s);</span>
<span class="fc" id="L150">            } catch (final IllegalArgumentException e) {</span>
<span class="fc" id="L151">                throw new ParsingException(&quot;Could not parse as DataTime!&quot;, e);</span>
            }
        }
    };

<span class="fc" id="L156">    private DataType(final String uri, final DataType supertype) {</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">        this.xsdType = uri == null ? null : URI.create(uri);</span>
<span class="fc" id="L158">        this.supertype = supertype;</span>
<span class="fc" id="L159">    }</span>

    /**
     * The XSD type, if any, with which this DataType is associated
     */
    public final URI xsdType;

    /**
     * This DataType, recorded because Java doesn't handle lexical &quot;this&quot; as we might like.
     */
<span class="fc" id="L169">    final DataType self = this;</span>

    /**
     * The immediate supertype of this DataType.
     */
    final DataType supertype;

    /**
     * A memoized form of the supertypes of this DataType, used to avoid redoing this recursive calculation during
     * operation.
     */
<span class="fc" id="L180">    private final Supplier&lt;Set&lt;DataType&gt;&gt; supertypesSupplier = memoize(new Supplier&lt;Set&lt;DataType&gt;&gt;() {</span>

        @Override
        public Set&lt;DataType&gt; get() {
<span class="fc" id="L184">            return EnumSet.of(self, EnumSet.of(supertype, supertype.supertypes().toArray(new DataType[0]))</span>
                    .toArray(
                            new DataType[0]));
        }
    });

    /**
     * @return The supertypes of this type, including itself.
     */
    public Set&lt;DataType&gt; supertypes() {
<span class="fc" id="L194">        return supertypesSupplier.get();</span>
    }

    /**
     * Map from lex to Java value.
     * 
     * @param s
     * @return s parsed into an instance of a Java type representing this {@link DataType}
     * @throws ParsingException
     */
    abstract public &lt;T extends Comparable&lt;T&gt;&gt; T parse(final String s) throws ParsingException;

    /**
     * @param s A value to parse
     * @return a {@link Set} of those DataTypes into which s can be parsed
     */
    public static Set&lt;DataType&gt; parseableAs(final String s) {
<span class="fc" id="L211">        return filter(allOf(DataType.class), new Predicate&lt;DataType&gt;() {</span>

            @Override
            public boolean apply(final DataType t) {
                try {
<span class="fc" id="L216">                    t.parse(s.trim());</span>
<span class="fc" id="L217">                    return true;</span>
<span class="fc" id="L218">                } catch (final ParsingException e) {</span>
<span class="fc" id="L219">                    return false;</span>
                }
            }
        });
    }

    /**
     * An ordering by type hierarchy. Those types with more supertypes are considered &quot;larger&quot; than those with fewer.
     */
<span class="fc" id="L228">    public static final Comparator&lt;DataType&gt; orderingByHierarchy = new Comparator&lt;DataType&gt;() {</span>

        @Override
        public int compare(final DataType left, final DataType right) {
<span class="fc" id="L232">            return left.supertypes().size() - right.supertypes().size();</span>
        }
    };

    /**
     * @param types The types to compare.
     * @return The first type with as &quot;bottom-most&quot; as position in the hierarchy as any other.
     */
    public static DataType firstMostRestrictiveType(final Collection&lt;DataType&gt; types) {
<span class="fc" id="L241">        return max(types, orderingByHierarchy);</span>
    }

    // private static final Logger log = getLogger(DataType.class);

    /**
     * How to recognize a Boolean lex for true.
     */
<span class="fc" id="L249">    public static final Pattern BOOLEAN_TRUE = compile(&quot;true|t&quot;, CASE_INSENSITIVE);</span>

    /**
     * How to recognize a Boolean lex for false.
     */
<span class="fc" id="L254">    public static final Pattern BOOLEAN_FALSE = compile(&quot;false|f&quot;, CASE_INSENSITIVE);</span>

<span class="fc" id="L256">    static final Function&lt;java.lang.String, Float&gt; string2float = new Function&lt;String, Float&gt;() {</span>

        @Override
        public Float apply(final java.lang.String seg) {
<span class="fc" id="L260">            return parseFloat(seg);</span>
        }
    };

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span></div></body></html>