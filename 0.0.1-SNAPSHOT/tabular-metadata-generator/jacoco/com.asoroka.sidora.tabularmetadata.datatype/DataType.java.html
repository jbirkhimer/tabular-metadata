<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DataType.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Tabular Metadata Generator</a> &gt; <a href="index.source.html" class="el_package">com.asoroka.sidora.tabularmetadata.datatype</a> &gt; <span class="el_source">DataType.java</span></div><h1>DataType.java</h1><pre class="source lang-java linenums">/**
 * TEMPORARY LICENSE HEADER STANDIN
 * REPLACE WITH APPROPRIATE SIDORA LICENSE
 */

package com.asoroka.sidora.tabularmetadata.datatype;

import static com.google.common.base.Suppliers.memoize;
import static com.google.common.collect.FluentIterable.from;
import static com.google.common.collect.Lists.transform;
import static com.google.common.collect.Sets.filter;
import static java.lang.Float.parseFloat;
import static java.lang.Integer.parseInt;
import static java.util.Arrays.asList;
import static java.util.EnumSet.allOf;
import static java.util.EnumSet.complementOf;
import static java.util.EnumSet.copyOf;
import static java.util.EnumSet.of;
import static java.util.regex.Pattern.CASE_INSENSITIVE;
import static java.util.regex.Pattern.compile;
import static javax.xml.XMLConstants.W3C_XML_SCHEMA_NS_URI;
import static org.joda.time.format.ISODateTimeFormat.dateTimeParser;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.Comparator;
import java.util.EnumSet;
import java.util.List;
import java.util.SortedSet;
import java.util.regex.Pattern;

import org.joda.time.DateTime;

import com.google.common.base.Function;
import com.google.common.base.Predicate;
import com.google.common.base.Supplier;

/**
 * This enumeration constructs
 * &lt;ul&gt;
 * &lt;li&gt;our &quot;native&quot; type system, as well as&lt;/li&gt;
 * &lt;li&gt;maps from lexical spaces in our system to selected portions of selected value spaces in the Java type system,
 * and&lt;/li&gt;
 * &lt;li&gt;maps from our types to types in the XSD type system.&lt;/li&gt;
 * &lt;/ul&gt;
 * It also offers convenience methods for working with our type system.
 * 
 * @author ajs6f
 */
<span class="fc" id="L50">public enum DataType {</span>

<span class="fc" id="L52">    String(W3C_XML_SCHEMA_NS_URI + &quot;#string&quot;, null) {</span>

        /*
         * This override indicates that String is the top type.
         */
        @Override
        public EnumSet&lt;DataType&gt; supertypes() {
<span class="fc" id="L59">            return of((DataType) this);</span>
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public String parse(final java.lang.String s) {
<span class="fc" id="L65">            return s;</span>
        }
    },
<span class="fc" id="L68">    Decimal(W3C_XML_SCHEMA_NS_URI + &quot;#decimal&quot;, String) {</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public Float parse(final java.lang.String s) throws ParsingException {
            try {
<span class="fc" id="L74">                return parseFloat(s.trim());</span>
<span class="fc" id="L75">            } catch (final NumberFormatException e) {</span>
<span class="fc" id="L76">                throw new ParsingException(&quot;Could not parse as Decimal!&quot;, e);</span>
            }
        }
    },
<span class="fc" id="L80">    Integer(W3C_XML_SCHEMA_NS_URI + &quot;#integer&quot;, Decimal) {</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public Integer parse(final java.lang.String s) throws ParsingException {
            try {
<span class="fc" id="L86">                return parseInt(s.trim());</span>
<span class="fc" id="L87">            } catch (final NumberFormatException e) {</span>
<span class="fc" id="L88">                throw new ParsingException(&quot;Could not parse as Integer!&quot;, e);</span>
            }
        }
    },
<span class="fc" id="L92">    URI(W3C_XML_SCHEMA_NS_URI + &quot;#anyURI&quot;, String) {</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public URI parse(final java.lang.String s) throws ParsingException {
            try {
<span class="fc bfc" id="L98" title="All 2 branches covered.">                if (URI_REGEX.matcher(s).matches()) {</span>
<span class="fc" id="L99">                    return new URI(s);</span>
                }
<span class="fc" id="L101">                throw new URISyntaxException(s, &quot;Could not validate URI!&quot;);</span>
<span class="fc" id="L102">            } catch (final URISyntaxException e) {</span>
<span class="fc" id="L103">                throw new ParsingException(&quot;Could not parse as URI!&quot;, e);</span>
            }
        }
    },
<span class="fc" id="L107">    NonNegativeInteger(W3C_XML_SCHEMA_NS_URI + &quot;#nonNegativeInteger&quot;, Integer) {</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public Integer parse(final java.lang.String s) throws ParsingException {

<span class="fc" id="L113">            final Integer value = Integer.parse(s);</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">            if (value &gt; -1) {</span>
<span class="fc" id="L115">                return value;</span>
            }
<span class="fc" id="L117">            throw new ParsingException(&quot;Value was negative!&quot;);</span>
        }
    },
<span class="fc" id="L120">    PositiveInteger(W3C_XML_SCHEMA_NS_URI + &quot;#positiveInteger&quot;, NonNegativeInteger) {</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public Integer parse(final java.lang.String s) throws ParsingException {
<span class="fc" id="L125">            final Integer value = NonNegativeInteger.parse(s);</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">            if (value &gt; 0) {</span>
<span class="fc" id="L127">                return value;</span>
            }
<span class="fc" id="L129">            throw new ParsingException(&quot;Value was negative!&quot;);</span>
        }
    },
<span class="fc" id="L132">    Geographic(null, String) {</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public GeographicValue parse(final String s) throws ParsingException {
            try {
<span class="fc" id="L138">                final List&lt;Float&gt; parts = transform(asList(s.split(&quot;,&quot;)), string2float);</span>
<span class="fc" id="L139">                return new GeographicValue(parts);</span>
<span class="fc" id="L140">            } catch (final NumberFormatException e) {</span>
<span class="fc" id="L141">                throw new ParsingException(&quot;Could not parse as Geographic!&quot;, e);</span>
            }
        }
    },
<span class="fc" id="L145">    Boolean(W3C_XML_SCHEMA_NS_URI + &quot;#boolean&quot;, String) {</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public Boolean parse(final java.lang.String s) throws ParsingException {
<span class="fc bfc" id="L150" title="All 2 branches covered.">            if (BOOLEAN_TRUE.matcher(s).matches()) {</span>
<span class="fc" id="L151">                return true;</span>
            }
<span class="fc bfc" id="L153" title="All 2 branches covered.">            if (BOOLEAN_FALSE.matcher(s).matches()) {</span>
<span class="fc" id="L154">                return false;</span>
            }
<span class="fc" id="L156">            throw new ParsingException(&quot;Could not parse as Boolean!&quot;);</span>
        }
    },
<span class="fc" id="L159">    DateTime(W3C_XML_SCHEMA_NS_URI + &quot;#dateTime&quot;, String) {</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public DateTime parse(final java.lang.String s) throws ParsingException {
            try {
<span class="fc" id="L165">                return dateTimeParser().parseDateTime(s);</span>
<span class="fc" id="L166">            } catch (final IllegalArgumentException e) {</span>
<span class="fc" id="L167">                throw new ParsingException(&quot;Could not parse as DataTime!&quot;, e);</span>
            }
        }
    };

    public static final EnumSet&lt;DataType&gt; valuesSet() {
<span class="fc" id="L173">        return allOf(DataType.class);</span>
    }

<span class="fc" id="L176">    private DataType(final String uri, final DataType supertype) {</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">        this.xsdType = uri == null ? null : java.net.URI.create(uri);</span>
<span class="fc" id="L178">        this.supertype = supertype;</span>
<span class="fc" id="L179">    }</span>

    /**
     * The XSD type, if any, with which this DataType is associated
     */
    public final URI xsdType;

    /**
     * This DataType, recorded because Java doesn't handle lexical &quot;this&quot; as we might like.
     */
<span class="fc" id="L189">    final DataType self = this;</span>

    /**
     * The immediate supertype of this DataType.
     */
    final DataType supertype;

    /**
     * We memoize the calculation of supertypes to avoid redoing this recursion during operation.
     */
<span class="fc" id="L199">    private final Supplier&lt;EnumSet&lt;DataType&gt;&gt; supertypesMemo = memoize(new Supplier&lt;EnumSet&lt;DataType&gt;&gt;() {</span>

        @Override
        public EnumSet&lt;DataType&gt; get() {
<span class="fc" id="L203">            final EnumSet&lt;DataType&gt; types = copyOf(supertype.supertypes());</span>
<span class="fc" id="L204">            types.add(self);</span>
<span class="fc" id="L205">            return types;</span>
        }
    });

    /**
     * @return The supertypes of this type, including itself.
     */
    public EnumSet&lt;DataType&gt; supertypes() {
<span class="fc" id="L213">        return supertypesMemo.get();</span>
    }

    /**
     * Map from lex to Java value.
     * 
     * @param s
     * @return s parsed into an instance of a Java type representing this {@link DataType}
     * @throws ParsingException
     */
    abstract public &lt;T extends Comparable&lt;T&gt;&gt; T parse(final String s) throws ParsingException;

    /**
     * @param s A value to parse
     * @return an {@link EnumSet} of those DataTypes into which s can be parsed
     */
    public static EnumSet&lt;DataType&gt; parseableAs(final String s) {
<span class="fc" id="L230">        return copyOf(filter(DataType.valuesSet(), new Predicate&lt;DataType&gt;() {</span>

            @Override
            public boolean apply(final DataType t) {
                try {
<span class="fc" id="L235">                    t.parse(s);</span>
<span class="fc" id="L236">                    return true;</span>
<span class="fc" id="L237">                } catch (final ParsingException e) {</span>
<span class="fc" id="L238">                    return false;</span>
                }
            }
        }));
    }

    /**
     * @param value
     * @return an {@link EnumSet} of those DataTypes into which s cannot be parsed
     */
    public static EnumSet&lt;DataType&gt; notParseableAs(final String value) {
<span class="fc" id="L249">        return complementOf(parseableAs(value));</span>
    }

    /**
     * A simple ordering by hierarchy. Those types with more supertypes are considered &quot;smaller&quot; than those with
     * fewer.
     */
<span class="fc" id="L256">    public static final Comparator&lt;DataType&gt; orderingByHierarchy = new Comparator&lt;DataType&gt;() {</span>

        @Override
        public int compare(final DataType left, final DataType right) {
<span class="fc" id="L260">            return right.supertypes().size() - left.supertypes().size();</span>
        }
    };

    public static SortedSet&lt;DataType&gt; sortByHierarchy(final Iterable&lt;DataType&gt; types) {
<span class="fc" id="L265">        return from(types).toSortedSet(orderingByHierarchy);</span>
    }

    // private static final Logger log = getLogger(DataType.class);

    /**
     * How to recognize a Boolean lex for true.
     */
<span class="fc" id="L273">    public static final Pattern BOOLEAN_TRUE = compile(&quot;^true|t$&quot;, CASE_INSENSITIVE);</span>

    /**
     * How to recognize a Boolean lex for false.
     */
<span class="fc" id="L278">    public static final Pattern BOOLEAN_FALSE = compile(&quot;^false|f$&quot;, CASE_INSENSITIVE);</span>

    /**
     * We use the well-known regex from &lt;a href=&quot;http://tools.ietf.org/html/rfc3986#appendix-B&quot;&gt;the standard&lt;/a&gt; but
     * we disallow relative URIs.
     */
<span class="fc" id="L284">    static Pattern URI_REGEX = compile(&quot;^(([^:/?#]+):)(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?&quot;);</span>

<span class="fc" id="L286">    static final Function&lt;java.lang.String, Float&gt; string2float = new Function&lt;String, Float&gt;() {</span>

        @Override
        public Float apply(final java.lang.String seg) {
<span class="fc" id="L290">            return parseFloat(seg);</span>
        }
    };
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span></div></body></html>